-- Full Lineup Macro + UI (LocalScript)
-- Place this LocalScript into StarterGui or StarterPlayerScripts

-- === CONFIG / SETTINGS (keeps your existing structure defaults) ===
if not getgenv then getgenv = function() return _G end end
local _Genv = getgenv()

if not _Genv.Setting then _Genv.Setting = {} end
local Setting = _Genv.Setting

if not Setting.Melee then Setting.Melee = { ["Enable"] = true, ["Z"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["X"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["C"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["Delay"] = 1.5 } end
if not Setting.Sword then Setting.Sword = { ["Enable"] = true, ["Z"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["X"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["Delay"] = 1 } end
if not Setting.Gun then Setting.Gun = { ["Enable"] = true, ["Z"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["X"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["Delay"] = 1, ["GunMode"] = false } end
if not Setting.Fruit then Setting.Fruit = { ["Enable"] = true, ["Z"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["X"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["C"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["V"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["F"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["Delay"] = 1 } end

-- default macro control
local Macro = false

-- convenience references
local Players = game:GetService("Players")
local lp = Players.LocalPlayer
local RS = game:GetService("RunService")
local UIS = game:GetService("UserInputService")

-- mapping between friendly weapon type and in-game Tool.ToolTip we used previously
local ToolTipNameFor = {
    Fruit = "Blox Fruit",   -- your project uses "Blox Fruit" tooltip
    Melee = "Melee",
    Sword = "Sword",
    Gun = "Gun"
}

-- lineup queue
local LineUp = {} -- elements: { WeaponType = "Fruit"/"Melee"/..., Skill = "Z"/"X"/"C"/"V"/"F" }

-- === UTILITIES ===
local function down(key, hold)
    pcall(function()
        if not lp or not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then return end
        -- VirtualInputManager is not officially supported in some contexts; keep pcall
        local vim = game:GetService("VirtualInputManager")
        vim:SendKeyEvent(true, key, false, lp.Character.HumanoidRootPart)
        task.wait(hold or 0.1)
        vim:SendKeyEvent(false, key, false, lp.Character.HumanoidRootPart)
    end)
end

local function findToolByTooltip(tooltip)
    -- Search character first (equipped), then backpack
    if lp.Character then
        for _, c in pairs(lp.Character:GetChildren()) do
            if c:IsA("Tool") and c:FindFirstChild("ToolTip") and tostring(c.ToolTip) == tooltip then
                return c
            end
        end
    end
    for _, it in pairs(lp.Backpack:GetChildren()) do
        if it:IsA("Tool") and it:FindFirstChild("ToolTip") and tostring(it.ToolTip) == tooltip then
            return it
        end
    end
    return nil
end

local function equipByWeaponType(weaponType, timeout)
    -- weaponType: "Fruit"/"Melee"/"Sword"/"Gun"
    -- returns the tool instance (equipped)
    timeout = timeout or 3
    local tooltip = ToolTipNameFor[weaponType]
    if not tooltip then return nil end

    -- try equip tool with matching tooltip
    -- search backpack for the tool
    local player = lp
    local character = player.Character or player.CharacterAdded:Wait()

    -- try equip multiple times until found or timeout
    local start = tick()
    while tick() - start < timeout do
        local t = findToolByTooltip(tooltip)
        if t then
            -- equip it
            pcall(function()
                if player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
                    player.Character:FindFirstChildOfClass("Humanoid"):EquipTool(t)
                end
            end)
            -- wait a short moment for equip to take effect
            for _ = 1, 10 do
                task.wait(0.05)
                if character:FindFirstChildOfClass("Tool") then
                    local equipped = character:FindFirstChildOfClass("Tool")
                    if equipped and equipped.ToolTip and tostring(equipped.ToolTip) == tooltip then
                        return equipped
                    end
                end
            end
            -- if not equipped, try again
        end
        task.wait(0.1)
    end
    -- failed to equip
    return nil
end

-- get hold time from Setting for weaponType & key
local function holdTimeFor(weaponType, key)
    local s = nil
    if weaponType == "Fruit" then s = Setting.Fruit
    elseif weaponType == "Melee" then s = Setting.Melee
    elseif weaponType == "Sword" then s = Setting.Sword
    elseif weaponType == "Gun" then s = Setting.Gun
    end
    if s and s[key] and s[key].HoldTime then return s[key].HoldTime end
    return 0.1
end

-- wait until skill cooldown is zero (uses player's Main.Skills gui keyed by tool.Name)
local function waitForSkillReady(tool, key, maxwait)
    maxwait = maxwait or 10
    local start = tick()
    while tick() - start < maxwait do
        local ok, skillGui = pcall(function()
            return lp.PlayerGui:FindFirstChild("Main") and lp.PlayerGui.Main:FindFirstChild("Skills") and lp.PlayerGui.Main.Skills:FindFirstChild(tool.Name)
        end)
        if ok and skillGui then
            local keyFrame = skillGui:FindFirstChild(key)
            if keyFrame and keyFrame:FindFirstChild("Cooldown") then
                local size = keyFrame.Cooldown.AbsoluteSize
                -- If width is 0 means ready (in your original code you used <= 0)
                if size.X <= 0.5 then
                    return true
                end
            else
                -- fallback: if no cooldown element found, assume ready
                return true
            end
        end
        task.wait(0.08)
    end
    return false
end

-- === UI CREATION ===
local function MakeGui()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "LineupMacroGui"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = lp:WaitForChild("PlayerGui")

    local main = Instance.new("Frame", screenGui)
    main.Name = "Main"
    main.Size = UDim2.new(0, 340, 0, 420)
    main.Position = UDim2.new(0, 10, 0, 60)
    main.BackgroundColor3 = Color3.fromRGB(30,30,30)
    main.BorderSizePixel = 0
    main.Active = true
    main.Draggable = true

    local title = Instance.new("TextLabel", main)
    title.Size = UDim2.new(1, 0, 0, 28)
    title.Position = UDim2.new(0,0,0,0)
    title.BackgroundTransparency = 1
    title.Text = "Lineup Macro"
    title.TextColor3 = Color3.fromRGB(255,255,255)
    title.Font = Enum.Font.SourceSansBold
    title.TextSize = 18

    -- Weapon buttons
    local weapons = {"Melee","Sword","Gun","Fruit"}
    local selectedWeapon = nil

    local weaponHolder = Instance.new("Frame", main)
    weaponHolder.Size = UDim2.new(1, -16, 0, 36)
    weaponHolder.Position = UDim2.new(0,8,0,34)
    weaponHolder.BackgroundTransparency = 1

    local btns = {}
    for i, w in ipairs(weapons) do
        local b = Instance.new("TextButton", weaponHolder)
        b.Size = UDim2.new(0, 80, 1, 0)
        b.Position = UDim2.new(0, (i-1)*85, 0, 0)
        b.Text = w
        b.Name = "Weapon_"..w
        b.Font = Enum.Font.SourceSans
        b.TextSize = 14
        b.BackgroundColor3 = Color3.fromRGB(50,50,50)
        b.TextColor3 = Color3.fromRGB(230,230,230)
        b.AutoButtonColor = true
        btns[w] = b
    end

    -- Skill buttons
    local skills = {"Z","X","C","V","F"}
    local skillHolder = Instance.new("Frame", main)
    skillHolder.Size = UDim2.new(1, -16, 0, 36)
    skillHolder.Position = UDim2.new(0,8,0,78)
    skillHolder.BackgroundTransparency = 1

    local skillBtns = {}
    for i, s in ipairs(skills) do
        local b = Instance.new("TextButton", skillHolder)
        b.Size = UDim2.new(0, 60, 1, 0)
        b.Position = UDim2.new(0, (i-1)*66, 0, 0)
        b.Text = s
        b.Name = "Skill_"..s
        b.Font = Enum.Font.SourceSans
        b.TextSize = 16
        b.BackgroundColor3 = Color3.fromRGB(60,60,60)
        b.TextColor3 = Color3.fromRGB(240,240,240)
        skillBtns[s] = b
    end

    -- Selected display text
    local info = Instance.new("TextLabel", main)
    info.Size = UDim2.new(1, -16, 0, 28)
    info.Position = UDim2.new(0,8,0,122)
    info.BackgroundTransparency = 1
    info.TextSize = 14
    info.TextColor3 = Color3.fromRGB(220,220,220)
    info.Text = "Selected: None"

    -- Lineup frame (scrolling list)
    local lineupFrame = Instance.new("Frame", main)
    lineupFrame.Size = UDim2.new(1, -16, 0, 170)
    lineupFrame.Position = UDim2.new(0,8,0,158)
    lineupFrame.BackgroundColor3 = Color3.fromRGB(20,20,20)
    lineupFrame.BorderSizePixel = 0

    local uilist = Instance.new("ScrollingFrame", lineupFrame)
    uilist.Size = UDim2.new(1, -8, 1, -8)
    uilist.Position = UDim2.new(0,4,0,4)
    uilist.CanvasSize = UDim2.new(0,0,0,0)
    uilist.BackgroundTransparency = 1
    uilist.ScrollBarThickness = 6
    uilist.Name = "List"

    local uiLayout = Instance.new("UIListLayout", uilist)
    uiLayout.Padding = UDim.new(0,4)
    uiLayout.SortOrder = Enum.SortOrder.LayoutOrder

    -- Control buttons: Start/Stop / Clear
    local startBtn = Instance.new("TextButton", main)
    startBtn.Size = UDim2.new(0, 90, 0, 30)
    startBtn.Position = UDim2.new(0, 12, 1, -46)
    startBtn.Text = "Start"
    startBtn.Font = Enum.Font.SourceSansBold
    startBtn.TextSize = 16

    local stopBtn = Instance.new("TextButton", main)
    stopBtn.Size = UDim2.new(0, 90, 0, 30)
    stopBtn.Position = UDim2.new(0, 120, 1, -46)
    stopBtn.Text = "Stop"
    stopBtn.Font = Enum.Font.SourceSansBold
    stopBtn.TextSize = 16

    local clearBtn = Instance.new("TextButton", main)
    clearBtn.Size = UDim2.new(0, 90, 0, 30)
    clearBtn.Position = UDim2.new(0, 228, 1, -46)
    clearBtn.Text = "Clear"
    clearBtn.Font = Enum.Font.SourceSans
    clearBtn.TextSize = 16

    -- small helper to refresh info text and lineup UI
    local function refreshInfo()
        info.Text = "Selected: "..(selectedWeapon or "None")
        -- update scrolling content size
        local total = 0
        for _, v in ipairs(uilist:GetChildren()) do
            if v:IsA("Frame") then
                total = total + v.AbsoluteSize.Y + uiLayout.Padding.Offset
            end
        end
        uilist.CanvasSize = UDim2.new(0,0,0, total + 6)
    end

    local function makeListEntry(idx, entry)
        -- entry: { WeaponType = "Fruit", Skill = "C" }
        local f = Instance.new("Frame", uilist)
        f.Size = UDim2.new(1, -8, 0, 30)
        f.BackgroundColor3 = Color3.fromRGB(35,35,35)
        f.BorderSizePixel = 0
        f.Name = "Entry_"..idx

        local t = Instance.new("TextLabel", f)
        t.Size = UDim2.new(1, -70, 1, 0)
        t.Position = UDim2.new(0,6,0,0)
        t.BackgroundTransparency = 1
        t.Text = idx..": "..entry.WeaponType.." - "..entry.Skill
        t.TextSize = 16
        t.TextColor3 = Color3.fromRGB(235,235,235)
        t.Font = Enum.Font.SourceSans

        local rbtn = Instance.new("TextButton", f)
        rbtn.Size = UDim2.new(0, 54, 1, -6)
        rbtn.Position = UDim2.new(1, -60, 0, 3)
        rbtn.Text = "Remove"
        rbtn.Font = Enum.Font.SourceSans
        rbtn.TextSize = 14

        rbtn.MouseButton1Click:Connect(function()
            -- find index in LineUp (first match)
            for i, v in ipairs(LineUp) do
                if v == entry then
                    table.remove(LineUp, i)
                    -- rebuild list
                    for _, c in pairs(uilist:GetChildren()) do if c:IsA("Frame") then c:Destroy() end end
                    for i2, e2 in ipairs(LineUp) do makeListEntry(i2, e2) end
                    refreshInfo()
                    break
                end
            end
        end)
    end

    -- button behavior: selecting weapon
    for _, w in ipairs(weapons) do
        local b = btns[w]
        b.MouseButton1Click:Connect(function()
            selectedWeapon = w
            -- simple visual feedback
            for _, ww in ipairs(weapons) do
                btns[ww].BackgroundColor3 = Color3.fromRGB(50,50,50)
            end
            b.BackgroundColor3 = Color3.fromRGB(80,80,80)
            refreshInfo()
        end)
    end

    -- skill button behavior: add to lineup
    for _, s in ipairs(skills) do
        local b = skillBtns[s]
        b.MouseButton1Click:Connect(function()
            if not selectedWeapon then
                -- quick HUD flash (no snackbar here) â€” we just change text briefly
                local old = info.Text
                info.Text = "Select a Weapon first!"
                task.delay(1, function() info.Text = old end)
                return
            end
            -- add to lineup
            local entry = { WeaponType = selectedWeapon, Skill = s }
            table.insert(LineUp, entry)
            makeListEntry(#LineUp, entry)
            refreshInfo()
        end)
    end

    -- control buttons
    startBtn.MouseButton1Click:Connect(function()
        Macro = true
        startBtn.Text = "Running..."
    end)
    stopBtn.MouseButton1Click:Connect(function()
        Macro = false
        startBtn.Text = "Start"
    end)
    clearBtn.MouseButton1Click:Connect(function()
        LineUp = {}
        for _, c in pairs(uilist:GetChildren()) do if c:IsA("Frame") then c:Destroy() end end
        refreshInfo()
    end)

    refreshInfo()
end

-- create GUI
MakeGui()

-- === Macro Runner (background) ===
spawn(function()
    while task.wait(0.05) do
        if Macro and #LineUp > 0 then
            -- iterate a snapshot copy so UI removal won't break loop state; but we want to consume entries in order
            local i = 1
            while Macro and i <= #LineUp do
                local action = LineUp[i]
                if not action then break end

                -- get weapon type
                local wtype = action.WeaponType
                local skillKey = action.Skill

                -- check weapon Enabled in settings
                local allowed = true
                if wtype == "Fruit" then allowed = Setting.Fruit and Setting.Fruit.Enable
                elseif wtype == "Melee" then allowed = Setting.Melee and Setting.Melee.Enable
                elseif wtype == "Sword" then allowed = Setting.Sword and Setting.Sword.Enable
                elseif wtype == "Gun" then allowed = Setting.Gun and Setting.Gun.Enable
                end

                if not allowed then
                    -- skip this action
                    table.remove(LineUp, i)
                    continue
                end

                -- equip appropriate tool (attempt for a few seconds)
                local tool = equipByWeaponType(wtype, 4)
                if not tool then
                    -- cannot equip -> remove entry and continue
                    table.remove(LineUp, i)
                    continue
                end

                -- wait for skill ready (cooldown UI)
                local ok = waitForSkillReady(tool, skillKey, 8)
                if not ok then
                    -- skill not found or not ready in time: remove and continue
                    table.remove(LineUp, i)
                    continue
                end

                -- press the key with configured hold time
                local hold = holdTimeFor(wtype, skillKey)
                down(skillKey, hold)

                -- optional pause after skill from the weapon settings Delay or a fallback
                local delayAfter = 0.12
                if wtype == "Fruit" and Setting.Fruit and Setting.Fruit.Delay then delayAfter = Setting.Fruit.Delay end
                if wtype == "Melee" and Setting.Melee and Setting.Melee.Delay then delayAfter = Setting.Melee.Delay end
                if wtype == "Sword" and Setting.Sword and Setting.Sword.Delay then delayAfter = Setting.Sword.Delay end
                if wtype == "Gun" and Setting.Gun and Setting.Gun.Delay then delayAfter = Setting.Gun.Delay end

                task.wait(delayAfter)

                -- remove the executed action from the lineup (so the list gets consumed)
                table.remove(LineUp, i)
                -- i stays same because after removal next entry shifts into this index
            end

            -- after finishing current lineup, stop or loop? keep Macro true but will stop because LineUp is empty
            if #LineUp == 0 then
                Macro = false
                -- update start button text (if GUI exists)
                local gui = lp:FindFirstChild("PlayerGui") and lp.PlayerGui:FindFirstChild("LineupMacroGui")
                if gui and gui.Main and gui.Main:FindFirstChild("Start") then
                    pcall(function() gui.Main.Start.Text = "Start" end)
                end
            end
        end
    end
end)

-- === Helpful note to user (printed once) ===
warn("Lineup Macro loaded. Open GUI via PlayerGui.LineupMacroGui. Select weapon -> skill to add entries. Start to run.")

-- End of script
