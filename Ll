-- Lineup Macro v2 (improved)
-- Place as LocalScript in StarterGui or StarterPlayerScripts

-- ============== Settings (keep your existing structure) ==============
if not getgenv then getgenv = function() return _G end end
local _Genv = getgenv()

if not _Genv.Setting then _Genv.Setting = {} end
local Setting = _Genv.Setting

if not Setting.Melee then Setting.Melee = { ["Enable"] = true, ["Z"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["X"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["C"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["Delay"] = 1.5 } end
if not Setting.Sword then Setting.Sword = { ["Enable"] = true, ["Z"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["X"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["Delay"] = 1 } end
if not Setting.Gun then Setting.Gun = { ["Enable"] = true, ["Z"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["X"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["Delay"] = 1, ["GunMode"] = false } end
if not Setting.Fruit then Setting.Fruit = { ["Enable"] = true, ["Z"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["X"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["C"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["V"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["F"] = {["Enable"] = true, ["HoldTime"] = 0.1}, ["Delay"] = 1 } end

-- ============== Services & refs ==============
local Players = game:GetService("Players")
local lp = Players.LocalPlayer
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Mapping tooltip -> tooltip string used in tools
local ToolTipNameFor = {
    Fruit = "Blox Fruit",
    Melee = "Melee",
    Sword = "Sword",
    Gun = "Gun"
}

-- Lineup queue (consumed from front)
local LineUp = {} -- { { WeaponType = "Fruit", Skill = "C" }, ... }

-- Macro control
local Macro = false

-- ============== Utility functions ==============
local function safeDown(key, hold)
    hold = hold or 0.1
    pcall(function()
        if lp and lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
            VirtualInputManager:SendKeyEvent(true, key, false, lp.Character.HumanoidRootPart)
            task.wait(hold)
            VirtualInputManager:SendKeyEvent(false, key, false, lp.Character.HumanoidRootPart)
        end
    end)
end

local function findToolByTooltip(tooltip)
    -- look in character (equipped) first
    if lp.Character then
        for _, child in pairs(lp.Character:GetChildren()) do
            if child:IsA("Tool") and child:FindFirstChild("ToolTip") and tostring(child.ToolTip) == tooltip then
                return child
            end
        end
    end
    -- then backpack
    for _, it in pairs(lp.Backpack:GetChildren()) do
        if it:IsA("Tool") and it:FindFirstChild("ToolTip") and tostring(it.ToolTip) == tooltip then
            return it
        end
    end
    return nil
end

local function equipByWeaponType(weaponType, timeout)
    timeout = timeout or 4
    local tooltip = ToolTipNameFor[weaponType]
    if not tooltip then return nil end
    local start = tick()
    local character = lp.Character or lp.CharacterAdded:Wait()
    while tick() - start < timeout do
        local t = findToolByTooltip(tooltip)
        if t then
            -- attempt equip
            pcall(function()
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                if humanoid then humanoid:EquipTool(t) end
            end)
            -- wait shortly for equip to apply
            for _ = 1, 15 do
                task.wait(0.06)
                local equipped = character:FindFirstChildOfClass("Tool")
                if equipped and equipped:FindFirstChild("ToolTip") and tostring(equipped.ToolTip) == tooltip then
                    return equipped
                end
            end
        end
        task.wait(0.08)
    end
    return nil
end

local function getHoldFor(weaponType, key)
    local s
    if weaponType == "Fruit" then s = Setting.Fruit
    elseif weaponType == "Melee" then s = Setting.Melee
    elseif weaponType == "Sword" then s = Setting.Sword
    elseif weaponType == "Gun" then s = Setting.Gun
    end
    if s and s[key] and s[key].HoldTime then return s[key].HoldTime end
    return 0.1
end

-- Robust: find skill GUI node for given tool instance.
-- First try by tool.Name, fallback: search all children for something containing weaponType or tooltip fragment.
local function findSkillGuiForTool(tool, weaponType)
    if not lp.PlayerGui then return nil end
    local main = lp.PlayerGui:FindFirstChild("Main")
    if not main then return nil end
    local skills = main:FindFirstChild("Skills")
    if not skills then return nil end

    -- Try direct by tool.Name
    if tool and tool.Name and skills:FindFirstChild(tool.Name) then
        return skills[tool.Name]
    end

    -- fallback search: try to find a child whose name contains weaponType (case-insensitive)
    for _, child in pairs(skills:GetChildren()) do
        if child:IsA("Frame") or child:IsA("Folder") or child:IsA("ImageLabel") or child:IsA("TextLabel") then
            local lname = tostring(child.Name):lower()
            if weaponType and lname:find(weaponType:lower()) then
                return child
            end
        end
    end

    -- last resort: return first child (not ideal)
    return skills:GetChildren()[1]
end

-- Wait for skill to be ready (cooldown width nearly zero). Returns true if ready, false on timeout.
local function waitForSkillReadyGui(skillGui, key, maxWait)
    maxWait = maxWait or 8
    if not skillGui then return false end
    local start = tick()
    while tick() - start < maxWait do
        local kf = skillGui:FindFirstChild(key)
        if kf and kf:FindFirstChild("Cooldown") then
            local sizeX = kf.Cooldown.AbsoluteSize.X
            -- ready when near zero
            if sizeX <= 1 then
                return true
            end
        else
            -- If structure differs, assume it's ready (can't detect). Return true to avoid hanging.
            return true
        end
        task.wait(0.06)
    end
    return false
end

-- Wait until cooldown > 1 (indicating skill usage triggered) OR just wait short after pressing
local function waitForCooldownStart(skillGui, key, timeout)
    timeout = timeout or 3
    local start = tick()
    while tick() - start < timeout do
        local kf = skillGui and skillGui:FindFirstChild(key)
        if kf and kf:FindFirstChild("Cooldown") then
            if kf.Cooldown.AbsoluteSize.X > 1 then
                return true
            end
        else
            return true
        end
        task.wait(0.05)
    end
    return false
end

-- ============== UI (simpler) ==============
-- Build minimal UI: weapon buttons, skill buttons, lineup list, start/stop/clear.
local function MakeGui()
    if not lp then return end
    local playerGui = lp:WaitForChild("PlayerGui")
    if playerGui:FindFirstChild("LineupMacroGui") then playerGui.LineupMacroGui:Destroy() end

    local screenGui = Instance.new("ScreenGui", playerGui)
    screenGui.Name = "LineupMacroGui"
    screenGui.ResetOnSpawn = false

    local main = Instance.new("Frame", screenGui)
    main.Name = "Main"
    main.Size = UDim2.new(0, 360, 0, 430)
    main.Position = UDim2.new(0, 8, 0, 60)
    main.BackgroundColor3 = Color3.fromRGB(28,28,28)
    main.BorderSizePixel = 0
    main.Active = true
    main.Draggable = true

    local title = Instance.new("TextLabel", main)
    title.Size = UDim2.new(1, 0, 0, 28)
    title.Position = UDim2.new(0, 0, 0, 0)
    title.BackgroundTransparency = 1
    title.Text = "Lineup Macro (v2)"
    title.TextColor3 = Color3.fromRGB(255,255,255)
    title.Font = Enum.Font.SourceSansBold
    title.TextSize = 18

    -- Weapon buttons
    local weapons = {"Melee","Sword","Gun","Fruit"}
    local selectedWeapon = nil
    local weaponHolder = Instance.new("Frame", main)
    weaponHolder.Size = UDim2.new(1, -16, 0, 36)
    weaponHolder.Position = UDim2.new(0,8,0,34)
    weaponHolder.BackgroundTransparency = 1

    local btns = {}
    for i,w in ipairs(weapons) do
        local b = Instance.new("TextButton", weaponHolder)
        b.Name = "Btn_"..w
        b.Size = UDim2.new(0, 80, 1, 0)
        b.Position = UDim2.new(0, (i-1)*88, 0, 0)
        b.Text = w
        b.Font = Enum.Font.SourceSans
        b.TextSize = 14
        b.BackgroundColor3 = Color3.fromRGB(50,50,50)
        b.TextColor3 = Color3.fromRGB(230,230,230)
        btns[w] = b
    end

    -- Skill buttons
    local skills = {"Z","X","C","V","F"}
    local skillHolder = Instance.new("Frame", main)
    skillHolder.Size = UDim2.new(1, -16, 0, 36)
    skillHolder.Position = UDim2.new(0,8,0,78)
    skillHolder.BackgroundTransparency = 1

    local skillBtns = {}
    for i,s in ipairs(skills) do
        local b = Instance.new("TextButton", skillHolder)
        b.Name = "Skill_"..s
        b.Size = UDim2.new(0, 64, 1, 0)
        b.Position = UDim2.new(0, (i-1)*70, 0, 0)
        b.Text = s
        b.Font = Enum.Font.SourceSans
        b.TextSize = 16
        b.BackgroundColor3 = Color3.fromRGB(60,60,60)
        b.TextColor3 = Color3.fromRGB(240,240,240)
        skillBtns[s] = b
    end

    local info = Instance.new("TextLabel", main)
    info.Size = UDim2.new(1, -16, 0, 28)
    info.Position = UDim2.new(0,8,0,122)
    info.BackgroundTransparency = 1
    info.TextSize = 14
    info.TextColor3 = Color3.fromRGB(220,220,220)
    info.Text = "Selected: None"

    -- lineup list
    local lineupFrame = Instance.new("Frame", main)
    lineupFrame.Size = UDim2.new(1, -16, 0, 200)
    lineupFrame.Position = UDim2.new(0,8,0,158)
    lineupFrame.BackgroundColor3 = Color3.fromRGB(18,18,18)

    local scroll = Instance.new("ScrollingFrame", lineupFrame)
    scroll.Size = UDim2.new(1, -8, 1, -8)
    scroll.Position = UDim2.new(0,4,0,4)
    scroll.CanvasSize = UDim2.new(0,0,0,0)
    scroll.BackgroundTransparency = 1
    scroll.ScrollBarThickness = 6

    local layout = Instance.new("UIListLayout", scroll)
    layout.Padding = UDim.new(0,6)
    layout.SortOrder = Enum.SortOrder.LayoutOrder

    local function refreshCanvas()
        local total = 0
        for _, c in ipairs(scroll:GetChildren()) do
            if c:IsA("Frame") then total = total + c.AbsoluteSize.Y + layout.Padding.Offset end
        end
        scroll.CanvasSize = UDim2.new(0,0,0,total + 8)
    end

    local function rebuildList()
        for _, c in pairs(scroll:GetChildren()) do if c:IsA("Frame") then c:Destroy() end end
        for i, e in ipairs(LineUp) do
            local f = Instance.new("Frame", scroll)
            f.Size = UDim2.new(1, -8, 0, 30)
            f.BackgroundColor3 = Color3.fromRGB(36,36,36)
            local t = Instance.new("TextLabel", f)
            t.Size = UDim2.new(1, -96, 1, 0)
            t.Position = UDim2.new(0,8,0,0)
            t.BackgroundTransparency = 1
            t.Text = i..": "..e.WeaponType.." - "..e.Skill
            t.TextColor3 = Color3.fromRGB(230,230,230)
            t.Font = Enum.Font.SourceSans
            t.TextSize = 16
            local r = Instance.new("TextButton", f)
            r.Size = UDim2.new(0, 72, 1, -6)
            r.Position = UDim2.new(1, -80, 0, 3)
            r.Text = "Remove"
            r.Font = Enum.Font.SourceSans
            r.TextSize = 14
            r.MouseButton1Click:Connect(function()
                table.remove(LineUp, i)
                rebuildList()
                refreshCanvas()
            end)
        end
        refreshCanvas()
    end

    -- weapon button behavior
    for _, w in ipairs(weapons) do
        local b = btns[w]
        b.MouseButton1Click:Connect(function()
            selectedWeapon = w
            info.Text = "Selected: "..w
            -- visual highlight
            for _, ww in ipairs(weapons) do btns[ww].BackgroundColor3 = Color3.fromRGB(50,50,50) end
            b.BackgroundColor3 = Color3.fromRGB(84,84,84)
        end)
    end

    -- skill button behavior: add to lineup
    for _, s in ipairs(skills) do
        local b = skillBtns[s]
        b.MouseButton1Click:Connect(function()
            if not selectedWeapon then
                local old = info.Text
                info.Text = "Select a weapon first!"
                task.delay(1, function() if info then info.Text = old end end)
                return
            end
            table.insert(LineUp, { WeaponType = selectedWeapon, Skill = s })
            rebuildList()
        end)
    end

    -- controls
    local startBtn = Instance.new("TextButton", main)
    startBtn.Size = UDim2.new(0, 90, 0, 30)
    startBtn.Position = UDim2.new(0, 12, 1, -46)
    startBtn.Text = "Start"
    startBtn.Font = Enum.Font.SourceSansBold
    startBtn.TextSize = 16

    local stopBtn = Instance.new("TextButton", main)
    stopBtn.Size = UDim2.new(0, 90, 0, 30)
    stopBtn.Position = UDim2.new(0, 120, 1, -46)
    stopBtn.Text = "Stop"
    stopBtn.Font = Enum.Font.SourceSansBold
    stopBtn.TextSize = 16

    local clearBtn = Instance.new("TextButton", main)
    clearBtn.Size = UDim2.new(0, 90, 0, 30)
    clearBtn.Position = UDim2.new(0, 228, 1, -46)
    clearBtn.Text = "Clear"
    clearBtn.Font = Enum.Font.SourceSans
    clearBtn.TextSize = 16

    startBtn.MouseButton1Click:Connect(function()
        if #LineUp == 0 then
            info.Text = "Lineup is empty!"
            return
        end
        Macro = true
        startBtn.Text = "Running..."
        info.Text = "Macro running..."
    end)
    stopBtn.MouseButton1Click:Connect(function()
        Macro = false
        startBtn.Text = "Start"
        info.Text = "Macro stopped."
    end)
    clearBtn.MouseButton1Click:Connect(function()
        LineUp = {}
        rebuildList()
        info.Text = "Cleared lineup."
    end)
end

-- Build GUI
MakeGui()

-- ============== Macro runner (robust, ordered execution) ==============
spawn(function()
    while task.wait(0.08) do
        if Macro and #LineUp > 0 then
            -- Always operate on the first entry (index 1)
            local action = LineUp[1]
            if not action then
                Macro = false
                break
            end
            local wtype = action.WeaponType
            local key = action.Skill

            -- check allowed in Setting
            local allowed = true
            if wtype == "Fruit" then allowed = Setting.Fruit and Setting.Fruit.Enable
            elseif wtype == "Melee" then allowed = Setting.Melee and Setting.Melee.Enable
            elseif wtype == "Sword" then allowed = Setting.Sword and Setting.Sword.Enable
            elseif wtype == "Gun" then allowed = Setting.Gun and Setting.Gun.Enable
            end
            if not allowed then
                warn("Lineup Macro: weapon type disabled in settings, stopping. ("..tostring(wtype)..")")
                Macro = false
                break
            end

            print("[Lineup] Attempting action: "..wtype.." - "..key)

            -- equip the correct tool
            local tool = equipByWeaponType(wtype, 5)
            if not tool then
                warn("[Lineup] Failed to equip tool for "..tostring(wtype)..". Stopping macro.")
                Macro = false
                break
            end

            print("[Lineup] Equipped tool: "..tostring(tool.Name))

            -- find the skill GUI frame for this tool
            local skillGui = findSkillGuiForTool(tool, wtype)
            if not skillGui then
                warn("[Lineup] Could not find skill GUI for tool '"..tostring(tool.Name).."' (weaponType "..tostring(wtype).."). Stopping.")
                Macro = false
                break
            end

            -- wait until skill ready
            local ready = waitForSkillReadyGui(skillGui, key, 10)
            if not ready then
                warn("[Lineup] Skill "..key.." for tool "..tostring(tool.Name).." not ready within timeout. Stopping macro.")
                Macro = false
                break
            end

            print("[Lineup] Skill ready: "..key.." on "..tool.Name.." -> pressing key now")
            -- press key
            local hold = getHoldFor(wtype, key)
            safeDown(key, hold)

            -- wait for cooldown start (confirm usage) or small fallback wait
            local started = waitForCooldownStart(skillGui, key, 3)
            if not started then
                -- fallback short wait anyway
                task.wait(0.25)
            end

            -- delay after using based on weapon setting
            local delayAfter = 0.12
            if wtype == "Fruit" and Setting.Fruit and Setting.Fruit.Delay then delayAfter = Setting.Fruit.Delay end
            if wtype == "Melee" and Setting.Melee and Setting.Melee.Delay then delayAfter = Setting.Melee.Delay end
            if wtype == "Sword" and Setting.Sword and Setting.Sword.Delay then delayAfter = Setting.Sword.Delay end
            if wtype == "Gun" and Setting.Gun and Setting.Gun.Delay then delayAfter = Setting.Gun.Delay end
            task.wait(delayAfter)

            -- remove the executed first entry
            table.remove(LineUp, 1)
            -- update GUI list (rebuild)
            local gui = lp:FindFirstChild("PlayerGui") and lp.PlayerGui:FindFirstChild("LineupMacroGui")
            if gui and gui.Main then
                -- rebuild list function is local inside MakeGui. Simpler: destroy and recreate GUI elements by calling MakeGui again.
                -- To avoid destroying UI state, we'll try to update the scrolling content by firing a simple rebuild signal:
                -- (easiest approach: rebuild whole gui)
                gui:Destroy()
                MakeGui()
            end

            -- If no more entries, stop macro automatically
            if #LineUp == 0 then
                Macro = false
                local g = lp:FindFirstChild("PlayerGui") and lp.PlayerGui:FindFirstChild("LineupMacroGui")
                if g and g.Main then
                    pcall(function() g.Main:FindFirstChild("Start").Text = "Start" end)
                end
            end
        end
    end
end)

warn("Lineup Macro v2 loaded. Check Output for debug prints.")
